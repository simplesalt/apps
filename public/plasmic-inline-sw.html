<!-- 
Plasmic Service Worker - Inline Version
Copy this entire script block into Plasmic's Custom Code component
This avoids CORB issues by embedding the code directly
-->

<script>
(function() {
  'use strict';
  
  // Prevent multiple registrations
  if (window.plasmicSWLoaded) {
    console.log('Plasmic service worker already loaded');
    return;
  }
  window.plasmicSWLoaded = true;
  
  // Configuration
  const CONFIG = {
    workerUrl: 'https://nuywznihg08edfslfk29.api.simplesalt.company',
    routingUrl: 'https://apps.simplesalt.company/routing.json'
  };
  
  console.log('ğŸš€ Initializing Plasmic API Proxy (Inline)...');
  
  if (!('serviceWorker' in navigator)) {
    console.warn('âš ï¸ Service workers not supported');
    return;
  }
  
  // Wait for page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initServiceWorker);
  } else {
    initServiceWorker();
  }
  
  async function initServiceWorker() {
    try {
      console.log('ğŸ“‹ Fetching routing configuration...');
      
      // Fetch routing rules with CORS
      const response = await fetch(CONFIG.routingUrl, {
        mode: 'cors',
        credentials: 'omit'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch routing config: ${response.status}`);
      }
      
      const routingRules = await response.json();
      console.log('âœ… Routing rules loaded:', routingRules.length, 'rules');
      
      // Create service worker code inline
      const serviceWorkerCode = `
        // Plasmic API Proxy Service Worker (Inline)
        const routingRules = ${JSON.stringify(routingRules)};
        const proxyWorkerUrl = '${CONFIG.workerUrl}';
        
        console.log('ğŸ”§ Plasmic Service Worker starting with', routingRules.length, 'routing rules');
        
        self.addEventListener('install', (event) => {
          console.log('ğŸ“¦ Plasmic Service Worker installing...');
          self.skipWaiting();
        });
        
        self.addEventListener('activate', (event) => {
          console.log('ğŸ”„ Plasmic Service Worker activating...');
          event.waitUntil(self.clients.claim());
        });
        
        self.addEventListener('fetch', (event) => {
          const url = new URL(event.request.url);
          
          // Skip non-HTTP requests and same-origin requests
          if (!url.protocol.startsWith('http') || url.origin === self.location.origin) {
            return;
          }
          
          // Find matching routing rule
          const rule = routingRules.find(r => 
            url.hostname === r.domain || 
            url.hostname.endsWith('.' + r.domain) || 
            url.hostname.includes(r.domain)
          );
          
          // Only intercept if rule exists and requires proxying
          if (rule && (rule.authType === 2 || rule.authType === 3)) {
            console.log('ğŸ”„ Intercepting API call to:', url.hostname, 'via rule:', rule);
            
            event.respondWith(
              handleProxyRequest(event.request, rule, proxyWorkerUrl)
            );
          }
        });
        
        async function handleProxyRequest(request, rule, workerUrl) {
          try {
            // Prepare headers for proxy request
            const proxyHeaders = new Headers();
            
            // Copy safe headers from original request
            for (const [key, value] of request.headers.entries()) {
              const lowerKey = key.toLowerCase();
              if (!lowerKey.startsWith('cf-') && 
                  !lowerKey.startsWith('x-') &&
                  lowerKey !== 'host' &&
                  lowerKey !== 'origin' &&
                  lowerKey !== 'referer') {
                proxyHeaders.set(key, value);
              }
            }
            
            // Add proxy-specific headers
            proxyHeaders.set('X-Original-URL', request.url);
            proxyHeaders.set('X-Auth-Type', rule.authType.toString());
            if (rule.secretName) {
              proxyHeaders.set('X-Secret-Name', rule.secretName);
            }
            proxyHeaders.set('Origin', 'https://studio.plasmic.app');
            proxyHeaders.set('X-Forwarded-For', 'studio.plasmic.app');
            
            // Get request body if present
            let body = null;
            if (request.method !== 'GET' && request.method !== 'HEAD') {
              try {
                body = await request.clone().blob();
              } catch (e) {
                console.warn('Could not clone request body:', e);
              }
            }
            
            // Make proxy request
            const proxyResponse = await fetch(workerUrl, {
              method: request.method,
              headers: proxyHeaders,
              body: body,
              mode: 'cors',
              credentials: 'omit'
            });
            
            console.log('âœ… Proxy request completed:', proxyResponse.status, proxyResponse.statusText);
            
            // Create a new response to avoid CORB issues
            const responseBody = await proxyResponse.blob();
            const newResponse = new Response(responseBody, {
              status: proxyResponse.status,
              statusText: proxyResponse.statusText,
              headers: proxyResponse.headers
            });
            
            return newResponse;
            
          } catch (error) {
            console.error('âŒ Proxy request failed:', error);
            
            // Fallback to direct request
            console.log('ğŸ”„ Falling back to direct request...');
            try {
              return await fetch(request);
            } catch (fallbackError) {
              console.error('âŒ Fallback request also failed:', fallbackError);
              return new Response('Service temporarily unavailable', { 
                status: 503,
                statusText: 'Service Unavailable'
              });
            }
          }
        }
      `;
      
      // Register service worker with blob URL
      const blob = new Blob([serviceWorkerCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);
      
      const registration = await navigator.serviceWorker.register(swUrl, {
        scope: '/'
      });
      
      console.log('âœ… Plasmic service worker registered successfully');
      console.log('ğŸ“ Scope:', registration.scope);
      
      // Set up message handling
      setupMessageHandling();
      
      // Expose utilities for debugging
      window.plasmicAPI = {
        test: testAPI,
        getStatus: () => ({
          registered: true,
          scope: registration.scope,
          active: !!registration.active,
          config: CONFIG
        }),
        reload: () => location.reload(),
        unregister: async () => {
          const registrations = await navigator.serviceWorker.getRegistrations();
          for (let registration of registrations) {
            await registration.unregister();
          }
          console.log('ğŸ—‘ï¸ All service workers unregistered');
        }
      };
      
      console.log('ğŸ‰ Plasmic API proxy ready!');
      console.log('ğŸ’¡ Test with: window.plasmicAPI.test("https://api.hubapi.com/contacts/v1/lists")');
      console.log('ğŸ” Check status: window.plasmicAPI.getStatus()');
      
    } catch (error) {
      console.error('âŒ Failed to initialize Plasmic service worker:', error);
      
      // Show user-friendly error
      if (error.message.includes('fetch')) {
        console.error('ğŸ’¡ Tip: Make sure https://apps.simplesalt.company/routing.json is accessible');
      }
    }
  }
  
  function setupMessageHandling() {
    // Handle messages from service worker
    navigator.serviceWorker.addEventListener('message', (event) => {
      console.log('ğŸ“¨ Message from service worker:', event.data);
    });
  }
  
  async function testAPI(url) {
    try {
      console.log('ğŸ§ª Testing API call:', url);
      const startTime = Date.now();
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      
      const endTime = Date.now();
      console.log(`âœ… API test response: ${response.status} ${response.statusText} (${endTime - startTime}ms)`);
      
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        const data = await response.json();
        console.log('ğŸ“„ API test data:', data);
        return data;
      } else {
        const text = await response.text();
        console.log('ğŸ“„ API test response (text):', text.substring(0, 200) + '...');
        return text;
      }
    } catch (error) {
      console.error('âŒ API test failed:', error);
      throw error;
    }
  }
  
})();
</script>

<!-- 
Usage Instructions:

1. Copy the entire <script> block above
2. In Plasmic Studio, add a "Custom Code" component to your page
3. Paste the script into the component
4. The service worker will automatically register when the page loads

Testing:
- Open browser console in Plasmic Studio
- Look for "ğŸ‰ Plasmic API proxy ready!" message
- Test with: window.plasmicAPI.test("https://api.hubapi.com/contacts/v1/lists")
- Check status: window.plasmicAPI.getStatus()

Troubleshooting:
- If you see CORB errors, this inline version should resolve them
- If routing.json fails to load, check CORS settings on apps.simplesalt.company
- Use window.plasmicAPI.unregister() to clean up if needed
-->